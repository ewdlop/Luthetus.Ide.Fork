<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_dir_d5746557a2b08703fb8a56d986f6faef" xml:lang="en-US">
<title>Source/Lib/TextEditor/TextEditors/Models Directory Reference</title>
<indexterm><primary>Source/Lib/TextEditor/TextEditors/Models Directory Reference</primary></indexterm>
<para>

<para>/// TabIndex is used for the html attribute named: &apos;tabindex&apos; /// </para>
 
</para>
Directory dependency graph for Models:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="dir_d5746557a2b08703fb8a56d986f6faef_dep.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Directories    </title>
        <itemizedlist>
            <listitem><para>directory <link linkend="_dir_2fc4d8226f1c563d55c9a0c8ec4be3d5">Internals</link></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Files    </title>
        <itemizedlist>
            <listitem><para>file <link linkend="__category_8cs">Category.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__cursor_modifier_bag_text_editor_8cs">CursorModifierBagTextEditor.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__dynamic_view_model_adapter_text_editor_8cs">DynamicViewModelAdapterTextEditor.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__extension_no_period_facts_8cs">ExtensionNoPeriodFacts.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__i_tab_text_editor_8cs">ITabTextEditor.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__i_text_editor_dependent_component_8cs">ITextEditorDependentComponent.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__i_text_editor_edit_context_8cs">ITextEditorEditContext.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__i_text_editor_model_8cs">ITextEditorModel.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__i_text_editor_model_api_8cs">ITextEditorModelApi.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__i_text_editor_view_model_api_8cs">ITextEditorViewModelApi.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__keymap_args_kind_8cs">KeymapArgsKind.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__motion_kind_8cs">MotionKind.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__scrollbar_dimensions_8cs">ScrollbarDimensions.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_dimensions_8cs">TextEditorDimensions.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_8_main_8cs">TextEditorModel.Main.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_8_variables_8cs">TextEditorModel.Variables.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_api_8cs">TextEditorModelApi.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_extension_methods_8cs">TextEditorModelExtensionMethods.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_modifier_8_bad_8cs">TextEditorModelModifier.Bad.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_modifier_8_edit_methods_8cs">TextEditorModelModifier.EditMethods.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_modifier_8_in_progress_8cs">TextEditorModelModifier.InProgress.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_modifier_8_main_8cs">TextEditorModelModifier.Main.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_model_modifier_8_partitions_8cs">TextEditorModelModifier.Partitions.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_partition_8cs">TextEditorPartition.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_view_model_8cs">TextEditorViewModel.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_view_model_api_8cs">TextEditorViewModelApi.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__text_editor_view_model_modifier_8cs">TextEditorViewModelModifier.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__widget_block_8cs">WidgetBlock.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__widget_inline_8cs">WidgetInline.cs</link></para>
</listitem>
            <listitem><para>file <link linkend="__widget_overlay_8cs">WidgetOverlay.cs</link></para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>/// TabIndex is used for the html attribute named: &apos;tabindex&apos; /// </para>

<para>Text editor virtualization:</para>

<para>public record TextEditorViewModelDisplayParameters(Key&lt;TextEditorViewModel&gt; ViewModelKey) { public string WrapperStyleCssString { get; init; } = string.Empty; public string WrapperClassCssString { get; init; } = string.Empty; public string TextEditorStyleCssString { get; init; } = string.Empty; public string TextEditorClassCssString { get; init; } = string.Empty;</para>

<para>/// public int TabIndex { get; init; } = -1; public RenderFragment&lt;TextEditorRenderBatchValidated&gt;? ContextMenuRenderFragmentOverride { get; init; } public RenderFragment&lt;TextEditorRenderBatchValidated&gt;? AutoCompleteMenuRenderFragmentOverride { get; init; }</para>

<para>///</para>

<para>/// If left null, the default HandleAfterOnKeyDownAsync will be used. /// public Func&lt;ITextEditorEditContext, TextEditorModelModifier, TextEditorViewModelModifier, CursorModifierBagTextEditor, KeyboardEventArgs, TextEditorComponentData, Task&gt;? AfterOnKeyDownAsync { get; init; }</para>

<para>///</para>

<para>/// If left null, the default HandleAfterOnKeyDownRangeAsync will be used. /// /// If a batch handling of KeyboardEventArgs is performed, then this method will be invoked as opposed to /// AfterOnKeyDownAsyncFactory, and a list of KeyboardEventArgs will be provided, /// sorted such that the first index represents the first event fired, and the last index represents the last /// event fired. /// public Func&lt;ITextEditorEditContext, TextEditorModelModifier, TextEditorViewModelModifier, CursorModifierBagTextEditor, List&lt;KeyboardEventArgs&gt;, TextEditorComponentData, Task&gt;? AfterOnKeyDownRangeAsync { get; init; }</para>

<para>///</para>

<para>/// If set to false the Displays.Internals.Header will NOT render above the text editor. /// public bool IncludeHeaderHelperComponent { get; init; } = true;</para>

<para>///</para>

<para>/// HeaderButtonKinds contains the enum value that represents a button displayed in the optional component: TextEditorHeader. /// public ImmutableArray&lt;HeaderButtonKind&gt;? HeaderButtonKinds { get; init; }</para>

<para>///</para>

<para>/// If set to false the Displays.Internals.TextEditorFooter will NOT render below the text editor. /// public bool IncludeFooterHelperComponent { get; init; } = true;</para>

<para>///</para>

<para>/// If set to false: the Displays.Internals.GutterSection will NOT render. (i.e. line numbers will not render) /// public bool IncludeGutterComponent { get; init; } = true;</para>

<para>public bool IncludeContextMenuHelperComponent { get; init; } = true;</para>

<para>public ContextRecord ContextRecord { get; init; } = ContextFacts.TextEditorContext;</para>

<para>///</para>

<para>/// The integrated terminal logic needs a keymap, separate to that of the &apos;global&apos; keymap used by other text editors. /// Therefore, this property is used to provide the Keymaps.Models.Terminals.TextEditorKeymapTerminal /// to the integrated terminal.<?linebreak?><?linebreak?> /// /// This property is not intended for use in any other scenario. /// public Keymap? KeymapOverride { get; init; } }</para>

<para>public sealed partial class TextEditorViewModelDisplay : ComponentBase, IDisposable { [Inject] public IState&lt;TextEditorState&gt; TextEditorStateWrap { get; set; } = null!;</para>

<para>[Parameter] public TextEditorViewModelDisplayParameters ViewModelDisplayParameters { get; set; } = new();</para>

<para>private (Key&lt;TextEditorViewModel&gt; ViewModelKey, int Sequence) _viewModelSequenceTuple = (Key&lt;TextEditorViewModel&gt;.Empty, 0);</para>

<para>protected override void OnParametersSet() { if (ViewModelDisplayParameters.ViewModelKey != _viewModelSequenceTuple.ViewModelKey) { _viewModelSequenceTuple = (ViewModelDisplayParameters.ViewModelKey, 0); }</para>

<para>base.OnParametersSet(); }</para>

<para>protected override bool ShouldRender() { // Is this invocation to the base necessary? // And, where would it go if it were necessary. var shouldRender = base.ShouldRender();</para>

<para>// Goal is to create a back and forth communication where the UI notifies // some &apos;external&apos; code that it wishes to render the text editor. // I&apos;ll just call the &apos;external&apos; code the &apos;IState&lt;TextEditorState&gt; TextEditorStateWrap&apos; // but that isn&apos;t quite so accurate. // // Upon the very first render, &apos;ShouldRender()&apos; does not get invoked. // This should be fine, because we need to render at least once in order to draw // the text editor HTML element. // // The text editor HTML element goes on to take up 100% width and height of the parent element. // So, the very first render allows one to draw an empty text editor, and measure its width, and height. // // These width and height measurements can then be used for virtualization at a later point. // // Inside &apos;override Task OnAfterRenderAsync(bool firstRender)&apos; there is a conditional branch // that will cause a re-render if it is the first render. // // So, we now are at the start of the second render, in which &apos;ShouldRender&apos; will for the first time be ran. // // At this point we have the measurements of the text editor HTML element because an empty one was rendered. // // But, we don&apos;t have a virtualization result that tells us what content to display. // // So, we need to notify the TextEditorStateWrap that we intend to render something. // We pass to the TextEditorStateWrap our &apos;_viewModelSequenceTuple&apos;. // // If the _viewModelSequenceTuple.Sequence == (the most recent sequence in the TextEditorStateWrap) // then no render is needed, the UI is up to date. // // Anytime a model is modified, all of its corresponding ViewModels need to have their // Sequence incremented. // // As well, anytime a ViewModel itself is modified, increment its sequence. // // And if the text editor&apos;s settings are changed (such as the font size) then increment // the sequence for every ViewModel. // // But, its important to note that the previous events solely incremented the Sequence. // // It is up to the user interface (i.e. the text editor component) to notify its attempt // to render. // // At that moment, if the ViewModel&apos;s ObservedSequence is not equal to its // RunningSequence then the VirtualizationResult is to be calculated, // and &apos;false&apos; should be returned, because it would have rendered outdated // information. // // After the VirtualizationResult is calculated, trigger the UI to render. // This once again will enter this &apos;ShouldRender&apos; method. // // But, this time when notifying the &apos;TextEditorStateWrap&apos; that it intends to render, // the response is &apos;true&apos; because the ObservedSequence was updated to be equal to the // RunningSequence after the VirtualizationResult was calculated. // // So, true is returned and the content is rendered.</para>

<para>// As for the virtualization, there is no need for the JavaScript intersection observer. // The ITextEditorEditContext knows everything about the scroll position, and other data relating to the text editor. // So the virtualization can just be done then and there.</para>

<para>ViewModelDisplayParameters.ViewModelKey; }</para>

<para>// Random note before I forget: options changes should be done via a throttled effect that // triggers UI re-render 100x easier than what I&apos;m currently doing.</para>

<para>protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { // If we were to use the synchronous &apos;OnAfterRender&apos; version of this method. // Could we guarantee that an invocation to &apos;StateHasChanged&apos; would not // need to be put within an invocation to &apos;InvokeAsync&apos;? // // The worry being, an exception due to not being on the correct synchronization context. // If this override serves only to cause a re-render after the very first render, // then it may be a worthwhile optimization to swap this method to the synchronous version // if it would be safe to do so. await InvokeAsync(StateHasChanged); }</para>

<para>// Is this invocation to the base necessary? // And, where would it go if it were necessary. await base.OnAfterRenderAsync(); } } </para>
</section>
</section>
