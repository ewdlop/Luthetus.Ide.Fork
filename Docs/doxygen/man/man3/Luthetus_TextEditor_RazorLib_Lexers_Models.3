.TH "Luthetus.TextEditor.RazorLib.Lexers.Models" 3 "Version 1.0.0" "Luthetus.Ide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Luthetus.TextEditor.RazorLib.Lexers.Models
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBResourceUriFacts\fP"
.br
.ti -1c
.RI "interface \fBTextEditorLexerResult\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "record struct \fBResourceUri\fP (string Value)"
.br
.ti -1c
.RI "record struct \fBTextEditorTextSpan\fP (int StartingIndexInclusive, int EndingIndexExclusive, byte DecorationByte, \fBResourceUri\fP \fBResourceUri\fP, string SourceText)"
.br
.RI "TODO: I have a suspicion that this type takes an absurd amount of memory\&.\&.\&. \&.\&.\&. the initial way of implementing this type was to store the text at the time of constructing the text span\&. | But, it was thought that preferably one would only only create the substring when asked for it\&. | This means one has to store the entirety of the source text\&. Well, the source text is just a reference not a copy of the value\&. So this seemed fine enough\&. | But, because the text editor is immutable\&. The source text is constantly needing to be reconstructed as a string value\&. | As a result, the old string values that pertain to previous iterations of the text editor must be held in memory, because any TextEditorTextSpan that is not garbage collected, would have a reference to the old string value\&. | I'm thinking of using Span<char> or something along the lines\&. But, wouldn't Span<char> still need to maintain the previous string in its entirety? | If Span<T> will somehow track what section of the previous string I have a reference to, and only free the resources pertaining to the sections of the string that don't have a Span<T> referencing them then that would be amazing\&. | But then again, why am I not just letting the text span capture the substring upon construction? | I also wonder, what about a Func<string>? Does this somehow hide the previous string values of the text editor and permit the resources to be free'd? (2024-07-27)\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "record struct Luthetus\&.TextEditor\&.RazorLib\&.Lexers\&.Models\&.ResourceUri (string Value)"

.PP
Definition at line \fB3\fP of file \fBResourceUri\&.cs\fP\&.
.SS "record struct Luthetus\&.TextEditor\&.RazorLib\&.Lexers\&.Models\&.TextEditorTextSpan (int StartingIndexInclusive, int EndingIndexExclusive, byte DecorationByte, \fBResourceUri\fP ResourceUri, string SourceText)"

.PP
TODO: I have a suspicion that this type takes an absurd amount of memory\&.\&.\&. \&.\&.\&. the initial way of implementing this type was to store the text at the time of constructing the text span\&. | But, it was thought that preferably one would only only create the substring when asked for it\&. | This means one has to store the entirety of the source text\&. Well, the source text is just a reference not a copy of the value\&. So this seemed fine enough\&. | But, because the text editor is immutable\&. The source text is constantly needing to be reconstructed as a string value\&. | As a result, the old string values that pertain to previous iterations of the text editor must be held in memory, because any TextEditorTextSpan that is not garbage collected, would have a reference to the old string value\&. | I'm thinking of using Span<char> or something along the lines\&. But, wouldn't Span<char> still need to maintain the previous string in its entirety? | If Span<T> will somehow track what section of the previous string I have a reference to, and only free the resources pertaining to the sections of the string that don't have a Span<T> referencing them then that would be amazing\&. | But then again, why am I not just letting the text span capture the substring upon construction? | I also wonder, what about a Func<string>? Does this somehow hide the previous string values of the text editor and permit the resources to be free'd? (2024-07-27)\&. Changed to a record-struct (was previously just a record) This type is not a 1 instance per file scenario\&. The type is instantiated many times for each file, and then again instantiated each time the file is re-parsed\&. So the instantiation/lifecycle of this type is lending it to being a struct\&. (2024-010-02) This constructor is used for text spans where their EndingIndexExclusive is the current position of a \fBStringWalker\fP\&.

.PP
This constructor is being used to experiment with not holding a reference to the SourceText (2024-07-27)

.PP
It is a bit clumsy since I'm still taking in the source text as an argument\&.

.PP
But the source text and the 'getTextPrecalculatedResult' share the same datatype and position in the constructor otherwise\&.

.PP
When using the record 'with' contextual keyword the _text might hold the cached value prior to the 'with' result\&.

.PP
Preferably one would never use FabricateTextSpan\&. This method is a hack, and a shortcut\&. 
.br

.br
 I'm currently (2023-08-03) writing code to 'load' the dotnet runtime assemblies into a CSharpBinder\&. This method is useful for now, and worth the technical debt, because I'm unsure of how to handle the \fBTextEditorTextSpan\fP representation of the metadata I'm reading\&. There is no file, so what do I do here? This method will be nice to track all the references to it, so later I can decide how to handle that\&.
.PP
Definition at line \fB48\fP of file \fBTextEditorTextSpan\&.cs\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Luthetus\&.Ide from the source code\&.
