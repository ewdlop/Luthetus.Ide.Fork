.TH "Luthetus.CompilerServices.CSharp.RuntimeAssemblies.IRuntimeAssembliesLoader" 3 "Version 1.0.0" "Luthetus.Ide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Luthetus.CompilerServices.CSharp.RuntimeAssemblies.IRuntimeAssembliesLoader \- https://learn.microsoft.com/en-us/dotnet/standard/assembly/inspect-contents-using-metadataloadcontext br/>
.br
 Purpose:
.br

.br
 Abstract System\&.Reflection\&.MetadataLoadContext usage to a single method invocation\&.
.br

.br
  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBCreateCache\fP (\fBCSharpBinder\fP cSharpBinder)"
.br
.in -1c
.SH "Detailed Description"
.PP 
https://learn.microsoft.com/en-us/dotnet/standard/assembly/inspect-contents-using-metadataloadcontext br/>
.br
 Purpose:
.br

.br
 Abstract System\&.Reflection\&.MetadataLoadContext usage to a single method invocation\&.
.br

.br
 

This method invocation uses reflection to make a readonly 'cache' of the runtime types\&.
.br

.br

.PP
The 'cache' is more so just a representation of the runtime types as if the source code itself were passed to the \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParser\fP
.br

.br

.PP
The idea is to create the 'cache' once per \&.NET version that a user requests to reference\&. Then re-use the 'cache' until the application is closed\&.
.br

.br

.PP
(re-creation of the cache would be done each time the application is opened\&.)
.br

.br
 
.PP
Definition at line \fB23\fP of file \fBIRuntimeAssembliesLoader\&.cs\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.RuntimeAssemblies\&.IRuntimeAssembliesLoader\&.CreateCache (\fBCSharpBinder\fP cSharpBinder)"


.SH "Author"
.PP 
Generated automatically by Doxygen for Luthetus\&.Ide from the source code\&.
