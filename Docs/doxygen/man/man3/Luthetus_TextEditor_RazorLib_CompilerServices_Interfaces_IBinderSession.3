.TH "Luthetus.TextEditor.RazorLib.CompilerServices.Interfaces.IBinderSession" 3 "Version 1.0.0" "Luthetus.Ide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Luthetus.TextEditor.RazorLib.CompilerServices.Interfaces.IBinderSession \- The CSharpBinder is being instantiated, then re-used many times foreach C# resource\&. This allows the files to know of eachother but, some data should only last for the length of a particular resource being parsed\&. Opposed to the lifetime of the CSharpBinder instance\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "int \fBGetNextIndexKey\fP ()"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "ResourceUri \fBResourceUri\fP\fR [get]\fP"
.br
.ti -1c
.RI "\fBIBinder\fP \fBBinder\fP\fR [get]\fP"
.br
.ti -1c
.RI "int \fBCurrentScopeIndexKey\fP\fR [get, set]\fP"
.br
.ti -1c
.RI "\fBNamespaceStatementNode\fP \fBCurrentNamespaceStatementNode\fP\fR [get, set]\fP"
.br
.ti -1c
.RI "List< \fBUsingStatementNode\fP > \fBCurrentUsingStatementNodeList\fP\fR [get, set]\fP"
.br
.ti -1c
.RI "DiagnosticBag \fBDiagnosticBag\fP\fR [get]\fP"
.br
.ti -1c
.RI "List< \fBIScope\fP > \fBScopeList\fP\fR [get]\fP"
.br
.ti -1c
.RI "Dictionary< \fBScopeKeyAndIdentifierText\fP, \fBTypeDefinitionNode\fP > \fBScopeTypeDefinitionMap\fP\fR [get]\fP"
.br
.RI "Key is the name of the type, prefixed with the ScopeKey and '_' to separate the ScopeKey from the type\&. Given: public class \fBMyClass\fP { } Then: Key == new ScopeKeyAndIdentifierText(ScopeKey, "MyClass")\&. "
.ti -1c
.RI "Dictionary< \fBScopeKeyAndIdentifierText\fP, \fBFunctionDefinitionNode\fP > \fBScopeFunctionDefinitionMap\fP\fR [get]\fP"
.br
.RI "Key is the name of the function, prefixed with the ScopeKey and '_' to separate the ScopeKey from the function\&. Given: public void MyMethod() { } Then: Key == new ScopeKeyAndIdentifierText(ScopeKey, "MyMethod")\&. "
.ti -1c
.RI "Dictionary< \fBScopeKeyAndIdentifierText\fP, \fBIVariableDeclarationNode\fP > \fBScopeVariableDeclarationMap\fP\fR [get]\fP"
.br
.RI "Key is the name of the variable, prefixed with the ScopeKey and '_' to separate the ScopeKey from the variable\&. Given: var myVariable = 2; Then: Key == new ScopeKeyAndIdentifierText(ScopeKey, "myVariable")\&. "
.ti -1c
.RI "Dictionary< int, \fBTypeClauseNode\fP > \fBScopeReturnTypeClauseNodeMap\fP\fR [get]\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The CSharpBinder is being instantiated, then re-used many times foreach C# resource\&. This allows the files to know of eachother but, some data should only last for the length of a particular resource being parsed\&. Opposed to the lifetime of the CSharpBinder instance\&. 

The binder sessions will now be used specifically to parse a single ResourceUri\&. (pseudo code: 'parser\&.Parse(resourceUri)') creates a BinderSession for the resourceUri\&. | The \fBIBinder\fP needs to have a Dictionary that maps from a resourceUri to an \fBIBinderSession\fP\&. | The \fBBinder\fP's data can only be accessed via a thread safe mechanism\&. | After a file is parsed, replace the item in the dictionary for the resourceUri with the most recent \fBIBinderSession\fP for that resource uri\&. | But what about partial types that span many files? Uh I don't know\&. But I think this will illuminate the final answer which will support partial types\&. (2024-10-13)\&. 
.PP
Definition at line \fB29\fP of file \fBIBinderSession\&.cs\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "int Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.GetNextIndexKey ()"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.SH "Property Documentation"
.PP 
.SS "\fBIBinder\fP Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.Binder\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB32\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "\fBNamespaceStatementNode\fP Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.CurrentNamespaceStatementNode\fR [get]\fP, \fR [set]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB34\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "int Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.CurrentScopeIndexKey\fR [get]\fP, \fR [set]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB33\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "List<\fBUsingStatementNode\fP> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.CurrentUsingStatementNodeList\fR [get]\fP, \fR [set]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB35\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "DiagnosticBag Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.DiagnosticBag\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB37\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "ResourceUri Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.ResourceUri\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB31\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "Dictionary<\fBScopeKeyAndIdentifierText\fP, \fBFunctionDefinitionNode\fP> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.ScopeFunctionDefinitionMap\fR [get]\fP"

.PP
Key is the name of the function, prefixed with the ScopeKey and '_' to separate the ScopeKey from the function\&. Given: public void MyMethod() { } Then: Key == new ScopeKeyAndIdentifierText(ScopeKey, "MyMethod")\&. 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB50\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "List<\fBIScope\fP> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.ScopeList\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB38\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "Dictionary<int, \fBTypeClauseNode\fP> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.ScopeReturnTypeClauseNodeMap\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB57\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "Dictionary<\fBScopeKeyAndIdentifierText\fP, \fBTypeDefinitionNode\fP> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.ScopeTypeDefinitionMap\fR [get]\fP"

.PP
Key is the name of the type, prefixed with the ScopeKey and '_' to separate the ScopeKey from the type\&. Given: public class \fBMyClass\fP { } Then: Key == new ScopeKeyAndIdentifierText(ScopeKey, "MyClass")\&. 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB44\fP of file \fBIBinderSession\&.cs\fP\&.
.SS "Dictionary<\fBScopeKeyAndIdentifierText\fP, \fBIVariableDeclarationNode\fP> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinderSession\&.ScopeVariableDeclarationMap\fR [get]\fP"

.PP
Key is the name of the variable, prefixed with the ScopeKey and '_' to separate the ScopeKey from the variable\&. Given: var myVariable = 2; Then: Key == new ScopeKeyAndIdentifierText(ScopeKey, "myVariable")\&. 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinderSession\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Implementations\&.BinderSession\fP\&.
.PP
Definition at line \fB56\fP of file \fBIBinderSession\&.cs\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Luthetus\&.Ide from the source code\&.
