.TH "Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Nodes" 3 "Version 1.0.0" "Luthetus.Ide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Nodes
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBEnums\fP"
.br
.ti -1c
.RI "namespace \fBInterfaces\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBAmbiguousIdentifierExpressionNode\fP"
.br
.ti -1c
.RI "class \fBAmbiguousIdentifierNode\fP"
.br
.RI "Example usage: One finds a \fBIdentifierToken\fP, but must continue parsing in order to know if it is a reference to a function, type, variable, or etc\&.\&.\&. "
.ti -1c
.RI "class \fBArbitraryCodeBlockNode\fP"
.br
.ti -1c
.RI "class \fBAttributeNode\fP"
.br
.ti -1c
.RI "class \fBBadExpressionNode\fP"
.br
.RI "If the parser cannot parse an expression, then replace the expression result with an instance of this type\&. "
.ti -1c
.RI "class \fBBinaryExpressionNode\fP"
.br
.ti -1c
.RI "class \fBBinaryOperatorNode\fP"
.br
.ti -1c
.RI "class \fBCodeBlockNode\fP"
.br
.RI "The \fBCodeBlockNode\fP is used for storing a sequence of statements (or a single expression-statement)\&.
.br

.br
 Perhaps one might use \fBCodeBlockNode\fP for the body of a class definition, for example\&. "
.ti -1c
.RI "class \fBCommaSeparatedExpressionNode\fP"
.br
.RI "\fBCommaSeparatedExpressionNode\fP, \fBTupleExpressionNode\fP, and \fBLambdaExpressionNode\fP are all related\&. "
.ti -1c
.RI "class \fBCompilationUnit\fP"
.br
.RI "The \fBCompilationUnit\fP is used to represent a singular C# resource file (that is to say a singular file on the user's file system)\&.
.br

.br
 TODO: How should \fBCompilationUnit\fP work in regards to the C# 'partial' keyword, would many C# resource files need be stitched together into a single \fBCompilationUnit\fP? "
.ti -1c
.RI "class \fBConstraintNode\fP"
.br
.RI "Examples:
.br
\&. "
.ti -1c
.RI "class \fBConstructorDefinitionNode\fP"
.br
.ti -1c
.RI "class \fBConstructorInvocationExpressionNode\fP"
.br
.ti -1c
.RI "class \fBDoWhileStatementNode\fP"
.br
.ti -1c
.RI "class \fBEmptyExpressionNode\fP"
.br
.RI "One usage of the \fBEmptyExpressionNode\fP is for a \fBParenthesizedExpressionNode\fP which has no \fBParenthesizedExpressionNode\&.InnerExpression\fP\&. "
.ti -1c
.RI "class \fBEmptyNode\fP"
.br
.RI "At times, this node is used in place of 'null'\&. "
.ti -1c
.RI "class \fBEnumDefinitionNode\fP"
.br
.ti -1c
.RI "class \fBExplicitCastNode\fP"
.br
.ti -1c
.RI "class \fBForeachStatementNode\fP"
.br
.ti -1c
.RI "class \fBForStatementNode\fP"
.br
.ti -1c
.RI "class \fBFunctionArgumentEntryNode\fP"
.br
.RI "Used when defining a function\&. "
.ti -1c
.RI "class \fBFunctionArgumentsListingNode\fP"
.br
.RI "Used when defining a function\&. "
.ti -1c
.RI "class \fBFunctionDefinitionNode\fP"
.br
.RI "TODO: Track the open and close braces for the function body\&. "
.ti -1c
.RI "class \fBFunctionInvocationNode\fP"
.br
.ti -1c
.RI "class \fBFunctionParameterEntryNode\fP"
.br
.RI "Used when invoking a function\&. "
.ti -1c
.RI "class \fBFunctionParametersListingNode\fP"
.br
.RI "Used when invoking a function\&. "
.ti -1c
.RI "class \fBGenericArgumentEntryNode\fP"
.br
.RI "Used when defining a syntax which contains a generic type\&. "
.ti -1c
.RI "class \fBGenericArgumentsListingNode\fP"
.br
.RI "Used when defining a syntax which contains a generic type\&. "
.ti -1c
.RI "class \fBGenericParameterEntryNode\fP"
.br
.RI "Used when invoking a syntax which contains a generic type\&. "
.ti -1c
.RI "class \fBGenericParametersListingNode\fP"
.br
.RI "Used when invoking a syntax which contains a generic type\&. "
.ti -1c
.RI "class \fBIfStatementNode\fP"
.br
.ti -1c
.RI "class \fBInheritanceStatementNode\fP"
.br
.ti -1c
.RI "class \fBLambdaExpressionNode\fP"
.br
.RI "While parsing expression, it is necessary that there exists a node that indicates a lambda expression is being parsed\&. "
.ti -1c
.RI "class \fBLiteralExpressionNode\fP"
.br
.ti -1c
.RI "class \fBLockStatementNode\fP"
.br
.ti -1c
.RI "class \fBNamespaceGroupNode\fP"
.br
.ti -1c
.RI "class \fBNamespaceStatementNode\fP"
.br
.ti -1c
.RI "class \fBObjectInitializationNode\fP"
.br
.RI "TODO: Correctly implement this node\&. For now, just skip over it when parsing\&. "
.ti -1c
.RI "class \fBObjectInitializationParameterEntryNode\fP"
.br
.RI "I'm not sure how to go about property initialization of an object versus collection initialization\&. For now I'll rather hackily set the \fBExpressionNode\fP only if a comma immediately follows it\&. "
.ti -1c
.RI "class \fBObjectInitializationParametersListingNode\fP"
.br
.ti -1c
.RI "class \fBParenthesizedExpressionNode\fP"
.br
.ti -1c
.RI "class \fBPreprocessorLibraryReferenceStatementNode\fP"
.br
.ti -1c
.RI "class \fBReturnStatementNode\fP"
.br
.ti -1c
.RI "class \fBSwitchExpressionNode\fP"
.br
.ti -1c
.RI "class \fBSwitchStatementNode\fP"
.br
.ti -1c
.RI "class \fBTryStatementCatchNode\fP"
.br
.ti -1c
.RI "class \fBTryStatementFinallyNode\fP"
.br
.ti -1c
.RI "class \fBTryStatementNode\fP"
.br
.ti -1c
.RI "class \fBTryStatementTryNode\fP"
.br
.ti -1c
.RI "class \fBTupleExpressionNode\fP"
.br
.ti -1c
.RI "class \fBTypeClauseNode\fP"
.br
.RI "\fBTypeClauseNode\fP is used anywhere a type is referenced\&. "
.ti -1c
.RI "class \fBTypeDefinitionNode\fP"
.br
.RI "\fBTypeDefinitionNode\fP is used anywhere a type is defined\&. "
.ti -1c
.RI "class \fBUnaryExpressionNode\fP"
.br
.ti -1c
.RI "class \fBUnaryOperatorNode\fP"
.br
.ti -1c
.RI "class \fBUsingStatementNode\fP"
.br
.ti -1c
.RI "class \fBVariableAssignmentExpressionNode\fP"
.br
.ti -1c
.RI "class \fBVariableDeclarationNode\fP"
.br
.ti -1c
.RI "class \fBVariableReferenceNode\fP"
.br
.ti -1c
.RI "class \fBWhileStatementNode\fP"
.br
.ti -1c
.RI "class \fBWithExpressionNode\fP"
.br
.in -1c
.SH "Author"
.PP 
Generated automatically by Doxygen for Luthetus\&.Ide from the source code\&.
