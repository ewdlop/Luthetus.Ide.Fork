.TH "Luthetus.TextEditor.RazorLib.CompilerServices.Interfaces.IParserModel" 3 "Version 1.0.0" "Luthetus.Ide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Luthetus.TextEditor.RazorLib.CompilerServices.Interfaces.IParserModel
.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.SS "Properties"

.in +1c
.ti -1c
.RI "\fBIBinder\fP \fBBinder\fP\fR [get]\fP"
.br
.ti -1c
.RI "\fBIBinderSession\fP \fBBinderSession\fP\fR [get]\fP"
.br
.ti -1c
.RI "TokenWalker \fBTokenWalker\fP\fR [get]\fP"
.br
.ti -1c
.RI "Stack< \fBISyntax\fP > \fBSyntaxStack\fP\fR [get, set]\fP"
.br
.RI "This property is likely to become obsolete\&. It is a hacky sort of 'catch all' case where one can push onto it whatever they want\&. "
.ti -1c
.RI "StatementBuilder \fBStatementBuilder\fP\fR [get, set]\fP"
.br
.RI "Unlike SyntaxStack there are more defined rules for this property\&. "
.ti -1c
.RI "List<(\fBSyntaxKind\fP DelimiterSyntaxKind, \fBIExpressionNode\fP ExpressionNode)> \fBExpressionList\fP\fR [get, set]\fP"
.br
.RI "This list permits primitive recursion via a while loop for the expression parsing logic\&. "
.ti -1c
.RI "\fBIExpressionNode\fP? \fBNoLongerRelevantExpressionNode\fP\fR [get, set]\fP"
.br
.RI "If a \fBParenthesizedExpressionNode\fP is determined to more accurately be described by a \fBCommaSeparatedExpressionNode\fP, then any state related to the \fBParenthesizedExpressionNode\fP instance needs to be cleared\&. "
.ti -1c
.RI "List< \fBSyntaxKind\fP > \fBTryParseExpressionSyntaxKindList\fP\fR [get]\fP"
.br
.RI "\fBTypeClauseNode\fP code exists in the expression code\&. As a result, some statements need to read a \fBTypeClauseNode\fP by invoking 'ParseExpression(\&.\&.\&.)'\&. "
.ti -1c
.RI "\fBIExpressionNode\fP \fBForceParseExpressionInitialPrimaryExpression\fP\fR [get, set]\fP"
.br
.RI "Something that is syntactically recursive but without creating a new scope needs to be parsed as an expression\&. "
.ti -1c
.RI "DiagnosticBag \fBDiagnosticBag\fP\fR [get]\fP"
.br
.ti -1c
.RI "\fBCodeBlockBuilder\fP \fBGlobalCodeBlockBuilder\fP\fR [get, set]\fP"
.br
.ti -1c
.RI "\fBCodeBlockBuilder\fP \fBCurrentCodeBlockBuilder\fP\fR [get, set]\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB10\fP of file \fBIParserModel\&.cs\fP\&.
.SH "Property Documentation"
.PP 
.SS "\fBIBinder\fP Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.Binder\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB12\fP of file \fBIParserModel\&.cs\fP\&.
.SS "\fBIBinderSession\fP Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.BinderSession\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB13\fP of file \fBIParserModel\&.cs\fP\&.
.SS "\fBCodeBlockBuilder\fP Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.CurrentCodeBlockBuilder\fR [get]\fP, \fR [set]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB117\fP of file \fBIParserModel\&.cs\fP\&.
.SS "DiagnosticBag Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.DiagnosticBag\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB115\fP of file \fBIParserModel\&.cs\fP\&.
.SS "List<(\fBSyntaxKind\fP DelimiterSyntaxKind, \fBIExpressionNode\fP ExpressionNode)> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.ExpressionList\fR [get]\fP, \fR [set]\fP"

.PP
This list permits primitive recursion via a while loop for the expression parsing logic\&. Each entry in the list is a "short circuit" such that if a child expression encounters the entry's DelimiterSyntaxKind, it will set the primary expression to the entry's ExpressionNode (of which is an ancestor expression to the child)\&.

.PP
After that, the restored primary expression "combines" with the child expression that "short circuit"-ed\&.

.PP
Then, the new primary expression expression node parses the 'DelimiterSyntaxKind' which triggered the "short circuit"\&.

.PP
The C# \fBIParserModel\fP implementation will only "short circuit" if the '\fBSyntaxKind\fP DelimiterSyntaxKind' is registered as a delimiter\&.

.PP
This is done in order to speed up the while loop, as the list of short circuits doesn't have to be iterated unless the current token is a possible delimiter\&.

.PP
Luthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.Internals\&.ParseOthers\&.SyntaxIsEndDelimiter(SyntaxKind syntaxKind) {\&.\&.\&.} 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB62\fP of file \fBIParserModel\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.ForceParseExpressionInitialPrimaryExpression\fR [get]\fP, \fR [set]\fP"

.PP
Something that is syntactically recursive but without creating a new scope needs to be parsed as an expression\&. TODO: It was decided to parse function arguments differently than how this example describes\&.\&.\&. \&.\&.\&.This example should be changed to one that is actually in use\&. For example: a function definition contains its arguments\&.

.PP
But, the arguments could contain an entry which is a \fBTypeClauseNode\fP that has \fBGenericArgumentEntryNode\fP of \fBTypeClauseNode\fP that also goes on to have its own \fBGenericArgumentEntryNode\fP\&.\&.\&.

.PP
So the expression code needs to be temporarily invoked from the statement code\&.

.PP
The example that was described is parsing a \fBFunctionArgumentsListingNode\fP\&.

.PP
The expression code only "naturally" can encounter a \fBFunctionParametersListingNode\fP which occurs from function invocation\&.

.PP
So, this property exists in order to change the initial primary expression that is used\&.

.PP
After every invocation of: Luthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.Internals\&.ParseOthers\&.TryParseExpression(SyntaxKind syntaxKind, CSharpParserModel model, out IExpressionNode expressionNode) {\&.\&.\&.}

.PP
This property will be reset to '\fBEmptyExpressionNode\&.Empty\fP'\&. (which is quite a hacky manner of going about things)\&. TODO: Consider making 'ForceParseExpressionInitialPrimaryExpression' an argument to the 'TryParseExpression' method?

.PP
Through this property, one can tell the expression code to parse a \fBFunctionArgumentsListingNode\fP by providing it as the initial expression\&. This must be done because it can never occur "naturally" by invoking the expression code and starting with '\fBEmptyExpressionNode\&.Empty\fP'\&. 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB113\fP of file \fBIParserModel\&.cs\fP\&.
.SS "\fBCodeBlockBuilder\fP Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.GlobalCodeBlockBuilder\fR [get]\fP, \fR [set]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB116\fP of file \fBIParserModel\&.cs\fP\&.
.SS "\fBIExpressionNode\fP? Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.NoLongerRelevantExpressionNode\fR [get]\fP, \fR [set]\fP"

.PP
If a \fBParenthesizedExpressionNode\fP is determined to more accurately be described by a \fBCommaSeparatedExpressionNode\fP, then any state related to the \fBParenthesizedExpressionNode\fP instance needs to be cleared\&. 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB69\fP of file \fBIParserModel\&.cs\fP\&.
.SS "StatementBuilder Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.StatementBuilder\fR [get]\fP, \fR [set]\fP"

.PP
Unlike SyntaxStack there are more defined rules for this property\&. It will be cleared after every \fBStatementDelimiterToken\fP, \fBOpenBraceToken\fP, and \fBCloseBraceToken\fP that is handled by the main loop\&.

.PP
The intent is to build up ambiguous syntax by pushing it onto this stack, then once it can be disambiguated, pop off all the syntax and construct an \fBISyntaxNode\fP\&.

.PP
A syntax for a definition is being treated as a 'Statement' here\&. So, to parse a \fBTypeDefinitionNode\fP one would check this for the access modifier (public, private, etc\&.\&.\&.)\&. 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB41\fP of file \fBIParserModel\&.cs\fP\&.
.SS "Stack<\fBISyntax\fP> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.SyntaxStack\fR [get]\fP, \fR [set]\fP"

.PP
This property is likely to become obsolete\&. It is a hacky sort of 'catch all' case where one can push onto it whatever they want\&. \fBStatementBuilder\fP is being added and is expected to fully replace this property\&. 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB24\fP of file \fBIParserModel\&.cs\fP\&.
.SS "TokenWalker Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.TokenWalker\fR [get]\fP"

.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB14\fP of file \fBIParserModel\&.cs\fP\&.
.SS "List<\fBSyntaxKind\fP> Luthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IParserModel\&.TryParseExpressionSyntaxKindList\fR [get]\fP"

.PP
\fBTypeClauseNode\fP code exists in the expression code\&. As a result, some statements need to read a \fBTypeClauseNode\fP by invoking 'ParseExpression(\&.\&.\&.)'\&. In order to "short circut" or "force exit" from the expression code back to the statement code: if the root primary expression is not equal to the model\&.ForceParseExpressionSyntaxKind then stop 'ParseExpression(\&.\&.\&.)' from consuming any further tokens\&.

.PP
Luthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.Internals\&.ParseOthers\&.TryParseExpression(SyntaxKind syntaxKind, CSharpParserModel model, out IExpressionNode expressionNode) {\&.\&.\&.} 
.PP
Implemented in \fBLuthetus\&.CompilerServices\&.CSharp\&.ParserCase\&.CSharpParserModel\fP, and \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.ParserModel\fP\&.
.PP
Definition at line \fB81\fP of file \fBIParserModel\&.cs\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Luthetus\&.Ide from the source code\&.
