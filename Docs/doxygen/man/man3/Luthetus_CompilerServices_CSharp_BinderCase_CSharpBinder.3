.TH "Luthetus.CompilerServices.CSharp.BinderCase.CSharpBinder" 3 "Version 1.0.0" "Luthetus.Ide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Luthetus.CompilerServices.CSharp.BinderCase.CSharpBinder
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinder\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIExpressionNode\fP \fBAnyMergeToken\fP (\fBIExpressionNode\fP expressionPrimary, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.RI "Returns the new primary expression which will be the passed in 'expressionPrimary' if the parameters were not mergeable\&. "
.ti -1c
.RI "\fBIExpressionNode\fP \fBAnyMergeExpression\fP (\fBIExpressionNode\fP expressionPrimary, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.RI "Returns the new primary expression which will be the passed in 'expressionPrimary' if the parameters were not mergeable\&. "
.ti -1c
.RI "\fBIExpressionNode\fP \fBAmbiguousIdentifierMergeToken\fP (\fBAmbiguousIdentifierExpressionNode\fP ambiguousIdentifierExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBAmbiguousIdentifierMergeExpression\fP (\fBAmbiguousIdentifierExpressionNode\fP ambiguousIdentifierExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBForceDecisionAmbiguousIdentifier\fP (\fBIExpressionNode\fP expressionPrimary, \fBAmbiguousIdentifierExpressionNode\fP ambiguousIdentifierExpressionNode, \fBIParserModel\fP model, bool forceVariableReferenceNode=false)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBBadMergeToken\fP (\fBBadExpressionNode\fP badExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBBadMergeExpression\fP (\fBBadExpressionNode\fP badExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBBinaryMergeToken\fP (\fBBinaryExpressionNode\fP binaryExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBCommaSeparatedMergeToken\fP (\fBCommaSeparatedExpressionNode\fP commaSeparatedExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBCommaSeparatedMergeExpression\fP (\fBCommaSeparatedExpressionNode\fP commaSeparatedExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBConstructorInvocationMergeToken\fP (\fBConstructorInvocationExpressionNode\fP constructorInvocationExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBConstructorInvocationMergeExpression\fP (\fBConstructorInvocationExpressionNode\fP constructorInvocationExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBEmptyMergeToken\fP (\fBEmptyExpressionNode\fP emptyExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBExplicitCastMergeToken\fP (\fBExplicitCastNode\fP explicitCastNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBGenericParametersListingMergeToken\fP (\fBGenericParametersListingNode\fP genericParametersListingNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBGenericParametersListingMergeExpression\fP (\fBGenericParametersListingNode\fP genericParametersListingNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBFunctionParametersListingMergeToken\fP (\fBFunctionParametersListingNode\fP functionParametersListingNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBFunctionParametersListingMergeExpression\fP (\fBFunctionParametersListingNode\fP functionParametersListingNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBFunctionArgumentsListingMergeToken\fP (\fBFunctionArgumentsListingNode\fP functionArgumentsListingNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBFunctionArgumentsListingMergeExpression\fP (\fBFunctionArgumentsListingNode\fP functionArgumentsListingNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBLambdaMergeToken\fP (\fBLambdaExpressionNode\fP lambdaExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBLambdaMergeExpression\fP (\fBLambdaExpressionNode\fP lambdaExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBLiteralMergeToken\fP (\fBLiteralExpressionNode\fP literalExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.RI "I am not evaluating anything when parsing for the IDE, so for now I'm going to ignore the precedence, and just track the start and end of the expression more or less\&. "
.ti -1c
.RI "\fBIExpressionNode\fP \fBParenthesizedMergeToken\fP (\fBParenthesizedExpressionNode\fP parenthesizedExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBParenthesizedMergeExpression\fP (\fBParenthesizedExpressionNode\fP parenthesizedExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBTypeClauseMergeToken\fP (\fBTypeClauseNode\fP typeClauseNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBTypeClauseMergeExpression\fP (\fBTypeClauseNode\fP typeClauseNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBVariableAssignmentMergeToken\fP (\fBVariableAssignmentExpressionNode\fP variableAssignmentNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBVariableAssignmentMergeExpression\fP (\fBVariableAssignmentExpressionNode\fP variableAssignmentNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBFunctionInvocationMergeToken\fP (\fBFunctionInvocationNode\fP functionInvocationNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBFunctionInvocationMergeExpression\fP (\fBFunctionInvocationNode\fP functionInvocationNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "\fBIExpressionNode\fP \fBSetLambdaExpressionNodeVariableDeclarationNodeList\fP (\fBLambdaExpressionNode\fP lambdaExpressionNode, \fBIExpressionNode\fP expressionNode, \fBIParserModel\fP model)"
.br
.ti -1c
.RI "void \fBClearFromExpressionList\fP (\fBIExpressionNode\fP expressionNode, \fBIParserModel\fP model)"
.br
.RI "A \fBParenthesizedExpressionNode\fP expression will "become" a \fBCommaSeparatedExpressionNode\fP upon encounter a \fBCommaToken\fP within its parentheses\&. "
.ti -1c
.RI "\fBCSharpBinder\fP ()"
.br
.ti -1c
.RI "\fBIBinderSession\fP \fBStartBinderSession\fP (\fBResourceUri\fP resourceUri)"
.br
.RI "FinalizeBinderSession "
.ti -1c
.RI "void \fBFinalizeBinderSession\fP (\fBIBinderSession\fP binderSession)"
.br
.RI "StartBinderSession "
.ti -1c
.RI "\fBLiteralExpressionNode\fP \fBBindLiteralExpressionNode\fP (\fBLiteralExpressionNode\fP literalExpressionNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "\fBBinaryOperatorNode\fP \fBBindBinaryOperatorNode\fP (\fBIExpressionNode\fP leftExpressionNode, \fBISyntaxToken\fP operatorToken, \fBIExpressionNode\fP rightExpressionNode, \fBCSharpParserModel\fP parserModel)"
.br
.ti -1c
.RI "void \fBBindStringInterpolationExpression\fP (\fBDollarSignToken\fP dollarSignToken, \fBCSharpParserModel\fP model)"
.br
.RI "TODO: Construct a BoundStringInterpolationExpressionNode and identify the expressions within the string literal\&. For now I am just making the dollar sign the same color as a string literal\&. "
.ti -1c
.RI "void \fBBindStringVerbatimExpression\fP (\fBAtToken\fP atToken, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindFunctionDefinitionNode\fP (\fBFunctionDefinitionNode\fP functionDefinitionNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindFunctionOptionalArgument\fP (\fBFunctionArgumentEntryNode\fP functionArgumentEntryNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "\fBReturnStatementNode\fP \fBBindReturnStatementNode\fP (\fBKeywordToken\fP keywordToken, \fBIExpressionNode\fP expressionNode)"
.br
.RI "TODO: Validate that the returned bound expression node has the same result type as the enclosing scope\&. "
.ti -1c
.RI "\fBIfStatementNode\fP \fBBindIfStatementNode\fP (\fBKeywordToken\fP ifKeywordToken, \fBIExpressionNode\fP expressionNode)"
.br
.ti -1c
.RI "void \fBSetCurrentNamespaceStatementNode\fP (\fBNamespaceStatementNode\fP namespaceStatementNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindNamespaceStatementNode\fP (\fBNamespaceStatementNode\fP namespaceStatementNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindConstructorInvocationNode\fP ()"
.br
.ti -1c
.RI "\fBInheritanceStatementNode\fP \fBBindInheritanceStatementNode\fP (\fBTypeClauseNode\fP typeClauseNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindVariableDeclarationNode\fP (\fBIVariableDeclarationNode\fP variableDeclarationNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "\fBVariableReferenceNode\fP \fBConstructAndBindVariableReferenceNode\fP (\fBIdentifierToken\fP variableIdentifierToken, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindVariableAssignmentExpressionNode\fP (\fBVariableAssignmentExpressionNode\fP variableAssignmentExpressionNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindConstructorDefinitionIdentifierToken\fP (\fBIdentifierToken\fP identifierToken, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindFunctionInvocationNode\fP (\fBFunctionInvocationNode\fP functionInvocationNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindNamespaceReference\fP (\fBIdentifierToken\fP namespaceIdentifierToken, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindTypeClauseNode\fP (\fBTypeClauseNode\fP typeClauseNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindTypeIdentifier\fP (\fBIdentifierToken\fP identifierToken, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindUsingStatementNode\fP (\fBUsingStatementNode\fP usingStatementNode, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "\fBAttributeNode\fP \fBBindAttributeNode\fP (\fBOpenSquareBracketToken\fP openSquareBracketToken, List< \fBISyntaxToken\fP > innerTokens, \fBCloseSquareBracketToken\fP closeSquareBracketToken, \fBCSharpParserModel\fP model)"
.br
.RI "TODO: Correctly implement this method\&. For now going to skip until the attribute closing square bracket\&. "
.ti -1c
.RI "void \fBOpenScope\fP (\fBICodeBlockOwner\fP codeBlockOwner, \fBTypeClauseNode\fP? scopeReturnTypeClauseNode, \fBTextEditorTextSpan\fP textSpan, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBAddNamespaceToCurrentScope\fP (string namespaceString, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBCloseScope\fP (\fBTextEditorTextSpan\fP textSpan, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBBindTypeDefinitionNode\fP (\fBTypeDefinitionNode\fP typeDefinitionNode, \fBCSharpParserModel\fP model, bool shouldOverwrite=false)"
.br
.ti -1c
.RI "void \fBCreateVariableSymbol\fP (\fBIdentifierToken\fP identifierToken, \fBVariableKind\fP variableKind, \fBCSharpParserModel\fP model)"
.br
.ti -1c
.RI "void \fBClearStateByResourceUri\fP (\fBResourceUri\fP resourceUri)"
.br
.RI "Do not invoke this when re-parsing the same file\&. "
.ti -1c
.RI "bool \fBTryGetFunctionHierarchically\fP (\fBIParserModel\fP? parserModel, \fBResourceUri\fP resourceUri, int initialScopeIndexKey, string identifierText, out \fBFunctionDefinitionNode\fP? functionDefinitionNode)"
.br
.RI "Search hierarchically through all the scopes, starting at the initialScope\&.
.br

.br
 If a match is found, then set the out parameter to it and return true\&.
.br

.br
 If none of the searched scopes contained a match then set the out parameter to null and return false\&. "
.ti -1c
.RI "bool \fBTryGetTypeDefinitionHierarchically\fP (\fBIParserModel\fP? parserModel, \fBResourceUri\fP resourceUri, int initialScopeIndexKey, string identifierText, out \fBTypeDefinitionNode\fP? typeDefinitionNode)"
.br
.RI "Search hierarchically through all the scopes, starting at the initialScope\&.
.br

.br
 If a match is found, then set the out parameter to it and return true\&.
.br

.br
 If none of the searched scopes contained a match then set the out parameter to null and return false\&. "
.ti -1c
.RI "bool \fBTryGetVariableDeclarationHierarchically\fP (\fBIParserModel\fP? parserModel, \fBResourceUri\fP resourceUri, int initialScopeIndexKey, string identifierText, out \fBIVariableDeclarationNode\fP? variableDeclarationStatementNode)"
.br
.RI "Search hierarchically through all the scopes, starting at the _currentScope\&.
.br

.br
 If a match is found, then set the out parameter to it and return true\&.
.br

.br
 If none of the searched scopes contained a match then set the out parameter to null and return false\&. "
.ti -1c
.RI "\fBIScope\fP? \fBGetScope\fP (\fBIParserModel\fP? model, \fBTextEditorTextSpan\fP textSpan)"
.br
.ti -1c
.RI "\fBIScope\fP? \fBGetScopeByPositionIndex\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int positionIndex)"
.br
.ti -1c
.RI "\fBIScope\fP? \fBGetScopeByScopeIndexKey\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"
.br
.ti -1c
.RI "\fBIScope\fP?[] \fBGetScopeList\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri)"
.br
.ti -1c
.RI "bool \fBTryGetBinderSession\fP (\fBIParserModel\fP? parserModel, \fBResourceUri\fP resourceUri, out \fBIBinderSession\fP binderSession)"
.br
.RI "If the resourceUri is the in progress \fBBinderSession\fP's ResourceUri, then the in progress instance should be returned via the out variable\&. "
.ti -1c
.RI "void \fBUpsertBinderSession\fP (\fBIBinderSession\fP binderSession)"
.br
.ti -1c
.RI "bool \fBRemoveBinderSession\fP (\fBResourceUri\fP resourceUri)"
.br
.RI "Returns true if the entry was removed\&. "
.ti -1c
.RI "\fBTypeDefinitionNode\fP[] \fBGetTypeDefinitionNodesByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"
.br
.ti -1c
.RI "bool \fBTryGetTypeDefinitionNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string typeIdentifierText, out \fBTypeDefinitionNode\fP typeDefinitionNode)"
.br
.ti -1c
.RI "bool \fBTryAddTypeDefinitionNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string typeIdentifierText, \fBTypeDefinitionNode\fP typeDefinitionNode)"
.br
.ti -1c
.RI "void \fBSetTypeDefinitionNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string typeIdentifierText, \fBTypeDefinitionNode\fP typeDefinitionNode)"
.br
.ti -1c
.RI "\fBFunctionDefinitionNode\fP[] \fBGetFunctionDefinitionNodesByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"
.br
.ti -1c
.RI "bool \fBTryGetFunctionDefinitionNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string functionIdentifierText, out \fBFunctionDefinitionNode\fP functionDefinitionNode)"
.br
.ti -1c
.RI "bool \fBTryAddFunctionDefinitionNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string functionIdentifierText, \fBFunctionDefinitionNode\fP functionDefinitionNode)"
.br
.ti -1c
.RI "void \fBSetFunctionDefinitionNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string functionIdentifierText, \fBFunctionDefinitionNode\fP functionDefinitionNode)"
.br
.ti -1c
.RI "\fBIVariableDeclarationNode\fP[] \fBGetVariableDeclarationNodesByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"
.br
.ti -1c
.RI "bool \fBTryGetVariableDeclarationNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string variableIdentifierText, out \fBIVariableDeclarationNode\fP variableDeclarationNode)"
.br
.ti -1c
.RI "bool \fBTryAddVariableDeclarationNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string variableIdentifierText, \fBIVariableDeclarationNode\fP variableDeclarationNode)"
.br
.ti -1c
.RI "void \fBSetVariableDeclarationNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string variableIdentifierText, \fBIVariableDeclarationNode\fP variableDeclarationNode)"
.br
.ti -1c
.RI "\fBTypeClauseNode\fP? \fBGetReturnTypeClauseNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"
.br
.ti -1c
.RI "bool \fBTryAddReturnTypeClauseNodeByScope\fP (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, \fBTypeClauseNode\fP typeClauseNode)"
.br
.ti -1c
.RI "\fBTextEditorTextSpan\fP? \fBGetDefinition\fP (\fBIParserModel\fP? model, \fBTextEditorTextSpan\fP textSpan, \fBICompilerServiceResource\fP compilerServiceResource)"
.br
.ti -1c
.RI "\fBISyntaxNode\fP? \fBGetSyntaxNode\fP (int positionIndex, \fBCompilationUnit\fP compilationUnit)"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "ImmutableDictionary< string, \fBNamespaceGroupNode\fP > \fBNamespaceGroupNodes\fP\fR [get]\fP"
.br
.ti -1c
.RI "ImmutableArray< \fBISymbol\fP > \fBSymbols\fP\fR [get]\fP"
.br
.ti -1c
.RI "Dictionary< string, \fBSymbolDefinition\fP > \fBSymbolDefinitions\fP\fR [get]\fP"
.br
.ti -1c
.RI "ImmutableDictionary< \fBNamespaceAndTypeIdentifiers\fP, \fBTypeDefinitionNode\fP > \fBAllTypeDefinitions\fP\fR [get]\fP"
.br
.ti -1c
.RI "ImmutableArray< \fBTextEditorDiagnostic\fP > \fBDiagnosticsList\fP\fR [get]\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB22\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.CSharpBinder ()"

.PP
Definition at line \fB41\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.AddNamespaceToCurrentScope (string namespaceString, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB644\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.AmbiguousIdentifierMergeExpression (\fBAmbiguousIdentifierExpressionNode\fP ambiguousIdentifierExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB317\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.AmbiguousIdentifierMergeToken (\fBAmbiguousIdentifierExpressionNode\fP ambiguousIdentifierExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB134\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.AnyMergeExpression (\fBIExpressionNode\fP expressionPrimary, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Returns the new primary expression which will be the passed in 'expressionPrimary' if the parameters were not mergeable\&. 
.PP
Definition at line \fB96\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.AnyMergeToken (\fBIExpressionNode\fP expressionPrimary, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Returns the new primary expression which will be the passed in 'expressionPrimary' if the parameters were not mergeable\&. 
.PP
Definition at line \fB28\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BadMergeExpression (\fBBadExpressionNode\fP badExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB404\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BadMergeToken (\fBBadExpressionNode\fP badExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB397\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BinaryMergeToken (\fBBinaryExpressionNode\fP binaryExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB411\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBAttributeNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindAttributeNode (\fBOpenSquareBracketToken\fP openSquareBracketToken, List< \fBISyntaxToken\fP > innerTokens, \fBCloseSquareBracketToken\fP closeSquareBracketToken, \fBCSharpParserModel\fP model)"

.PP
TODO: Correctly implement this method\&. For now going to skip until the attribute closing square bracket\&. 
.PP
Definition at line \fB606\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBBinaryOperatorNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindBinaryOperatorNode (\fBIExpressionNode\fP leftExpressionNode, \fBISyntaxToken\fP operatorToken, \fBIExpressionNode\fP rightExpressionNode, \fBCSharpParserModel\fP parserModel)"

.PP
Definition at line \fB133\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindConstructorDefinitionIdentifierToken (\fBIdentifierToken\fP identifierToken, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB501\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindConstructorInvocationNode ()"

.PP
Definition at line \fB351\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindFunctionDefinitionNode (\fBFunctionDefinitionNode\fP functionDefinitionNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB224\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindFunctionInvocationNode (\fBFunctionInvocationNode\fP functionInvocationNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB513\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindFunctionOptionalArgument (\fBFunctionArgumentEntryNode\fP functionArgumentEntryNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB253\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIfStatementNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindIfStatementNode (\fBKeywordToken\fP ifKeywordToken, \fBIExpressionNode\fP expressionNode)"

.PP
Definition at line \fB305\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBInheritanceStatementNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindInheritanceStatementNode (\fBTypeClauseNode\fP typeClauseNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB356\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBLiteralExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindLiteralExpressionNode (\fBLiteralExpressionNode\fP literalExpressionNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB105\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindNamespaceReference (\fBIdentifierToken\fP namespaceIdentifierToken, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB545\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindNamespaceStatementNode (\fBNamespaceStatementNode\fP namespaceStatementNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB324\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBReturnStatementNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindReturnStatementNode (\fBKeywordToken\fP keywordToken, \fBIExpressionNode\fP expressionNode)"

.PP
TODO: Validate that the returned bound expression node has the same result type as the enclosing scope\&. 
.PP
Definition at line \fB296\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindStringInterpolationExpression (\fBDollarSignToken\fP dollarSignToken, \fBCSharpParserModel\fP model)"

.PP
TODO: Construct a BoundStringInterpolationExpressionNode and identify the expressions within the string literal\&. For now I am just making the dollar sign the same color as a string literal\&. 
.PP
Definition at line \fB204\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindStringVerbatimExpression (\fBAtToken\fP atToken, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB214\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindTypeClauseNode (\fBTypeClauseNode\fP typeClauseNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB557\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindTypeDefinitionNode (\fBTypeDefinitionNode\fP typeDefinitionNode, \fBCSharpParserModel\fP model, bool shouldOverwrite = \fRfalse\fP)"

.PP
Definition at line \fB720\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindTypeIdentifier (\fBIdentifierToken\fP identifierToken, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB580\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindUsingStatementNode (\fBUsingStatementNode\fP usingStatementNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB595\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindVariableAssignmentExpressionNode (\fBVariableAssignmentExpressionNode\fP variableAssignmentExpressionNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB461\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.BindVariableDeclarationNode (\fBIVariableDeclarationNode\fP variableDeclarationNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB375\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ClearFromExpressionList (\fBIExpressionNode\fP expressionNode, \fBIParserModel\fP model)"

.PP
A \fBParenthesizedExpressionNode\fP expression will "become" a \fBCommaSeparatedExpressionNode\fP upon encounter a \fBCommaToken\fP within its parentheses\&. An issue arises however, because the model\&.ExpressionList still says to "short circuit" when the \fBCloseParenthesisToken\fP is encountered, and to at this point make the \fBParenthesizedExpressionNode\fP the primary expression\&.

.PP
Well, the \fBParenthesizedExpressionNode\fP should no longer exist, it was deemed to be more accurately described by a \fBCommaSeparatedExpressionNode\fP\&.

.PP
So, this method will remove any entries in the model\&.ExpressionList that have the '\fBParenthesizedExpressionNode\fP' as the to-be primary expression\&. 
.PP
Definition at line \fB1565\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ClearStateByResourceUri (\fBResourceUri\fP resourceUri)"

.PP
Do not invoke this when re-parsing the same file\&. Instead, only invoke this when the file is deleted, and should no longer be included in the binder\&. 
.PP
Implements \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinder\fP\&.
.PP
Definition at line \fB869\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.CloseScope (\fBTextEditorTextSpan\fP textSpan, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB665\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.CommaSeparatedMergeExpression (\fBCommaSeparatedExpressionNode\fP commaSeparatedExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB483\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.CommaSeparatedMergeToken (\fBCommaSeparatedExpressionNode\fP commaSeparatedExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB464\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBVariableReferenceNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ConstructAndBindVariableReferenceNode (\fBIdentifierToken\fP variableIdentifierToken, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB418\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ConstructorInvocationMergeExpression (\fBConstructorInvocationExpressionNode\fP constructorInvocationExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB613\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ConstructorInvocationMergeToken (\fBConstructorInvocationExpressionNode\fP constructorInvocationExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB495\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.CreateVariableSymbol (\fBIdentifierToken\fP identifierToken, \fBVariableKind\fP variableKind, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB831\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.EmptyMergeToken (\fBEmptyExpressionNode\fP emptyExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB749\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ExplicitCastMergeToken (\fBExplicitCastNode\fP explicitCastNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB840\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.FinalizeBinderSession (\fBIBinderSession\fP binderSession)"

.PP
StartBinderSession 
.PP
Implements \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinder\fP\&.
.PP
Definition at line \fB100\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ForceDecisionAmbiguousIdentifier (\fBIExpressionNode\fP expressionPrimary, \fBAmbiguousIdentifierExpressionNode\fP ambiguousIdentifierExpressionNode, \fBIParserModel\fP model, bool forceVariableReferenceNode = \fRfalse\fP)"

.PP
Definition at line \fB329\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.FunctionArgumentsListingMergeExpression (\fBFunctionArgumentsListingNode\fP functionArgumentsListingNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB988\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.FunctionArgumentsListingMergeToken (\fBFunctionArgumentsListingNode\fP functionArgumentsListingNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB975\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.FunctionInvocationMergeExpression (\fBFunctionInvocationNode\fP functionInvocationNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB1398\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.FunctionInvocationMergeToken (\fBFunctionInvocationNode\fP functionInvocationNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB1385\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.FunctionParametersListingMergeExpression (\fBFunctionParametersListingNode\fP functionParametersListingNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB950\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.FunctionParametersListingMergeToken (\fBFunctionParametersListingNode\fP functionParametersListingNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB937\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GenericParametersListingMergeExpression (\fBGenericParametersListingNode\fP genericParametersListingNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB880\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GenericParametersListingMergeToken (\fBGenericParametersListingNode\fP genericParametersListingNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB858\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBTextEditorTextSpan\fP? Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetDefinition (\fBIParserModel\fP? model, \fBTextEditorTextSpan\fP textSpan, \fBICompilerServiceResource\fP compilerServiceResource)"

.PP
Definition at line \fB1406\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBFunctionDefinitionNode\fP[] Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetFunctionDefinitionNodesByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"

.PP
Definition at line \fB1198\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBTypeClauseNode\fP? Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetReturnTypeClauseNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"

.PP
Definition at line \fB1368\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIScope\fP? Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetScope (\fBIParserModel\fP? model, \fBTextEditorTextSpan\fP textSpan)"

.PP
Definition at line \fB1010\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIScope\fP? Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetScopeByPositionIndex (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int positionIndex)"

.PP
Definition at line \fB1018\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIScope\fP? Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetScopeByScopeIndexKey (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"

.PP
Definition at line \fB1040\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIScope\fP?[] Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetScopeList (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri)"

.PP
Definition at line \fB1055\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBISyntaxNode\fP? Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetSyntaxNode (int positionIndex, \fBCompilationUnit\fP compilationUnit)"

.PP
Implements \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinder\fP\&.
.PP
Definition at line \fB1494\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBTypeDefinitionNode\fP[] Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetTypeDefinitionNodesByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"

.PP
Definition at line \fB1113\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIVariableDeclarationNode\fP[] Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.GetVariableDeclarationNodesByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey)"

.PP
Definition at line \fB1283\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.LambdaMergeExpression (\fBLambdaExpressionNode\fP lambdaExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB1123\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.LambdaMergeToken (\fBLambdaExpressionNode\fP lambdaExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB1016\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.LiteralMergeToken (\fBLiteralExpressionNode\fP literalExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
I am not evaluating anything when parsing for the IDE, so for now I'm going to ignore the precedence, and just track the start and end of the expression more or less\&. Reason for this being: object initialization and collection initialization currently will at times break the \fBParser\fP for an entire file, and therefore they are much higher priority\&. 
.PP
Definition at line \fB1141\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.OpenScope (\fBICodeBlockOwner\fP codeBlockOwner, \fBTypeClauseNode\fP? scopeReturnTypeClauseNode, \fBTextEditorTextSpan\fP textSpan, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB624\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ParenthesizedMergeExpression (\fBParenthesizedExpressionNode\fP parenthesizedExpressionNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB1187\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.ParenthesizedMergeToken (\fBParenthesizedExpressionNode\fP parenthesizedExpressionNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB1159\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.RemoveBinderSession (\fBResourceUri\fP resourceUri)"

.PP
Returns true if the entry was removed\&. 
.PP
Implements \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinder\fP\&.
.PP
Definition at line \fB1103\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.SetCurrentNamespaceStatementNode (\fBNamespaceStatementNode\fP namespaceStatementNode, \fBCSharpParserModel\fP model)"

.PP
Definition at line \fB317\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.SetFunctionDefinitionNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string functionIdentifierText, \fBFunctionDefinitionNode\fP functionDefinitionNode)"

.PP
Definition at line \fB1264\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.SetLambdaExpressionNodeVariableDeclarationNodeList (\fBLambdaExpressionNode\fP lambdaExpressionNode, \fBIExpressionNode\fP expressionNode, \fBIParserModel\fP model)"

.PP
Definition at line \fB1417\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.SetTypeDefinitionNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string typeIdentifierText, \fBTypeDefinitionNode\fP typeDefinitionNode)"

.PP
Definition at line \fB1179\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.SetVariableDeclarationNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string variableIdentifierText, \fBIVariableDeclarationNode\fP variableDeclarationNode)"

.PP
Definition at line \fB1349\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIBinderSession\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.StartBinderSession (\fBResourceUri\fP resourceUri)"

.PP
FinalizeBinderSession 
.PP
Implements \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinder\fP\&.
.PP
Definition at line \fB60\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryAddFunctionDefinitionNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string functionIdentifierText, \fBFunctionDefinitionNode\fP functionDefinitionNode)"

.PP
Definition at line \fB1243\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryAddReturnTypeClauseNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, \fBTypeClauseNode\fP typeClauseNode)"

.PP
Definition at line \fB1388\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryAddTypeDefinitionNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string typeIdentifierText, \fBTypeDefinitionNode\fP typeDefinitionNode)"

.PP
Definition at line \fB1158\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryAddVariableDeclarationNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string variableIdentifierText, \fBIVariableDeclarationNode\fP variableDeclarationNode)"

.PP
Definition at line \fB1328\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryGetBinderSession (\fBIParserModel\fP? parserModel, \fBResourceUri\fP resourceUri, out \fBIBinderSession\fP binderSession)"

.PP
If the resourceUri is the in progress \fBBinderSession\fP's ResourceUri, then the in progress instance should be returned via the out variable\&. TODO: This is quite confusingly written at the moment\&. 
.PP
Definition at line \fB1076\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryGetFunctionDefinitionNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string functionIdentifierText, out \fBFunctionDefinitionNode\fP functionDefinitionNode)"

.PP
Definition at line \fB1219\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryGetFunctionHierarchically (\fBIParserModel\fP? parserModel, \fBResourceUri\fP resourceUri, int initialScopeIndexKey, string identifierText, out \fBFunctionDefinitionNode\fP? functionDefinitionNode)"

.PP
Search hierarchically through all the scopes, starting at the initialScope\&.
.br

.br
 If a match is found, then set the out parameter to it and return true\&.
.br

.br
 If none of the searched scopes contained a match then set the out parameter to null and return false\&. 
.PP
Definition at line \fB904\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryGetTypeDefinitionHierarchically (\fBIParserModel\fP? parserModel, \fBResourceUri\fP resourceUri, int initialScopeIndexKey, string identifierText, out \fBTypeDefinitionNode\fP? typeDefinitionNode)"

.PP
Search hierarchically through all the scopes, starting at the initialScope\&.
.br

.br
 If a match is found, then set the out parameter to it and return true\&.
.br

.br
 If none of the searched scopes contained a match then set the out parameter to null and return false\&. 
.PP
Definition at line \fB940\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryGetTypeDefinitionNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string typeIdentifierText, out \fBTypeDefinitionNode\fP typeDefinitionNode)"

.PP
Definition at line \fB1134\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryGetVariableDeclarationHierarchically (\fBIParserModel\fP? parserModel, \fBResourceUri\fP resourceUri, int initialScopeIndexKey, string identifierText, out \fBIVariableDeclarationNode\fP? variableDeclarationStatementNode)"

.PP
Search hierarchically through all the scopes, starting at the _currentScope\&.
.br

.br
 If a match is found, then set the out parameter to it and return true\&.
.br

.br
 If none of the searched scopes contained a match then set the out parameter to null and return false\&. 
.PP
Definition at line \fB976\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "bool Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TryGetVariableDeclarationNodeByScope (\fBIParserModel\fP? model, \fBResourceUri\fP resourceUri, int scopeIndexKey, string variableIdentifierText, out \fBIVariableDeclarationNode\fP variableDeclarationNode)"

.PP
Definition at line \fB1304\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TypeClauseMergeExpression (\fBTypeClauseNode\fP typeClauseNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB1347\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.TypeClauseMergeToken (\fBTypeClauseNode\fP typeClauseNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB1234\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "void Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.UpsertBinderSession (\fBIBinderSession\fP binderSession)"

.PP
Implements \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinder\fP\&.
.PP
Definition at line \fB1088\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.VariableAssignmentMergeExpression (\fBVariableAssignmentExpressionNode\fP variableAssignmentNode, \fBIExpressionNode\fP expressionSecondary, \fBIParserModel\fP model)"

.PP
Definition at line \fB1371\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SS "\fBIExpressionNode\fP Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.VariableAssignmentMergeToken (\fBVariableAssignmentExpressionNode\fP variableAssignmentNode, \fBISyntaxToken\fP token, \fBIParserModel\fP model)"

.PP
Definition at line \fB1365\fP of file \fBCSharpBinder\&.Expressions\&.cs\fP\&.
.SH "Property Documentation"
.PP 
.SS "ImmutableDictionary<\fBNamespaceAndTypeIdentifiers\fP, \fBTypeDefinitionNode\fP> Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.AllTypeDefinitions\fR [get]\fP"

.PP
Definition at line \fB52\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "ImmutableArray<\fBTextEditorDiagnostic\fP> Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.DiagnosticsList\fR [get]\fP"

.PP
Implements \fBLuthetus\&.TextEditor\&.RazorLib\&.CompilerServices\&.Interfaces\&.IBinder\fP\&.
.PP
Definition at line \fB53\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "ImmutableDictionary<string, \fBNamespaceGroupNode\fP> Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.NamespaceGroupNodes\fR [get]\fP"

.PP
Definition at line \fB49\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "Dictionary<string, \fBSymbolDefinition\fP> Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.SymbolDefinitions\fR [get]\fP"

.PP
Definition at line \fB51\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.
.SS "ImmutableArray<\fBISymbol\fP> Luthetus\&.CompilerServices\&.CSharp\&.BinderCase\&.CSharpBinder\&.Symbols\fR [get]\fP"

.PP
Definition at line \fB50\fP of file \fBCSharpBinder\&.Main\&.cs\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Luthetus\&.Ide from the source code\&.
