\doxysection{Source/\+Lib/\+Extensions/\+Extensions.Dot\+Net Directory Reference}
\hypertarget{dir_2ff1e8bca114e08dc1de4be319417fc9}{}\label{dir_2ff1e8bca114e08dc1de4be319417fc9}\index{Source/Lib/Extensions/Extensions.DotNet Directory Reference@{Source/Lib/Extensions/Extensions.DotNet Directory Reference}}
Directory dependency graph for Extensions.\+Dot\+Net\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dir_2ff1e8bca114e08dc1de4be319417fc9_dep}
\end{center}
\end{figure}
\doxysubsubsection*{Directories}
\begin{DoxyCompactItemize}
\item 
directory \mbox{\hyperlink{dir_9d913068e6c4affffde742e5fe48e8cb}{App\+Datas}}
\item 
directory \mbox{\hyperlink{dir_19c3dee0d47e4f1b9cc8448c8f4ae0a8}{Background\+Tasks}}
\item 
directory \mbox{\hyperlink{dir_528f8a1716750964807facb321625d64}{Code\+Searches}}
\item 
directory \mbox{\hyperlink{dir_5b31d01861dc4bb549d770342f5e2c09}{Command\+Lines}}
\item 
directory \mbox{\hyperlink{dir_65807243c5bf6cb5dbc412353861ea87}{Commands}}
\item 
directory \mbox{\hyperlink{dir_ec62ea314ae628ab6d7d86f56e66963d}{Compiler\+Services}}
\item 
directory \mbox{\hyperlink{dir_f3ca841d0a622b2348765c689eff132a}{Component\+Renderers}}
\item 
directory \mbox{\hyperlink{dir_1227c07ec4840d7ab3982d0eca1e13ad}{CSharp\+Projects}}
\item 
directory \mbox{\hyperlink{dir_00813ed724a255122d25fe8019374816}{Dot\+Net\+Solutions}}
\item 
directory \mbox{\hyperlink{dir_7c940dc46d5413d47af636743cb6eb28}{Installations}}
\item 
directory \mbox{\hyperlink{dir_ce8869f7a945e684b73458ec5905fcaa}{Menus}}
\item 
directory \mbox{\hyperlink{dir_15bffcecbfce96897d51d61193422529}{Namespaces}}
\item 
directory \mbox{\hyperlink{dir_82d1ed0ff5eb8a3c603d069f94836b3b}{Nugets}}
\item 
directory \mbox{\hyperlink{dir_b6cde0c195b3573973f6a00666fd920e}{Outputs}}
\item 
directory \mbox{\hyperlink{dir_841a14003d42d44f482534d67bd21cec}{Shareds}}
\item 
directory \mbox{\hyperlink{dir_4463c34c33bac5675458a68af7967292}{Test\+Explorers}}
\item 
directory \mbox{\hyperlink{dir_4e85733844ba850d649447190abb0709}{Websites}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Luthetus.\+Compiler\+Services.\+Razor\+Lib.\+csproj is the way for a compiler service non-\/razor lib to provide razor components.

For example, one might primarily code in C\#, but occassionally have to write Java\+Script. Perhaps, this individual would prefer to load the Java\+Script Compiler\+Service, BUT NOT load the Java\+Script specific UI components.

I\textquotesingle{}m not certain on the best way to go about this "{}separate the compiler service from its UI components\textquotesingle{} idea. But this is how I\textquotesingle{}ll start to try.  \+Essentially I need to move all the .\+NET specific code that is in the \+Luthetus.\+Ide.\+Razor\+Lib.\+csproj to this project instead.  \+After I do that, I need to make the code generic so that any compiler service can decide to implement that blazor component.  \+For example, the solution explorer. I imagine that the name "{}Solution Explorer"{} could be changed based on some blazor parameter, and that the nodes in the tree could be populated with different logic, instead of from reading a .sln file and etc...

I have no idea how I would do that???? These components seem very specialized, and I think I even prefer it that way.

But do I really want 2 projects per programming language, one for the compiler service and one for the UI?

Move these\+: \mbox{[} \mbox{]} /\+CSharp\+Projects/ \mbox{[} \mbox{]} /\+Dot\+Net\+Solutions/ \mbox{[} \mbox{]} /\+Nugets/

\mbox{[} \mbox{]} /\+Command\+Lines/\+Models/\+Dot\+Net\+Cli\+Command\+Formatter.cs \mbox{[} \mbox{]} /\+Command\+Lines/\+Models/\+Dot\+Net\+Cli\+Output\+Parser.cs \mbox{[} \mbox{]} /\+Component\+Renderers/\+Models/\+INu\+Get\+Package\+Manager\+Renderer\+Type.cs \mbox{[} \mbox{]} /\+Component\+Renderers/\+Models/\+IRemove\+CSharp\+Project\+From\+Solution\+Renderer\+Type.cs \mbox{[} \mbox{]} /\+Component\+Renderers/\+Models/\+ITree\+View\+CSharp\+Project\+Nuget\+Package\+Reference\+Renderer\+Type.cs \mbox{[} \mbox{]} /\+Component\+Renderers/\+Models/\+ITree\+View\+CSharp\+Project\+To\+Project\+Reference\+Renderer\+Type.cs \mbox{[} \mbox{]} /\+Component\+Renderers/\+Models/\+ITree\+View\+Solution\+Folder\+Renderer\+Type.cs \mbox{[} \mbox{]} /\+Menus/\+Models/\+IMenu\+Options\+Factory.Remove\+CSharp\+Project\+Reference\+From\+Solution() \mbox{[} \mbox{]} /\+Menus/\+Models/\+IMenu\+Options\+Factory.Add\+Project\+To\+Project\+Reference() \mbox{[} \mbox{]} /\+Menus/\+Models/\+IMenu\+Options\+Factory.Remove\+Project\+To\+Project\+Reference() \mbox{[} \mbox{]} /\+Menus/\+Models/\+IMenu\+Options\+Factory.Move\+Project\+To\+Solution\+Folder() \mbox{[} \mbox{]} /\+Menus/\+Models/\+IMenu\+Options\+Factory.Remove\+Nu\+Get\+Package\+Reference\+From\+Project() \mbox{[} \mbox{]} Repeat what is done for \doxylink{_i_menu_options_factory_8cs}{IMenu\+Options\+Factory.\+cs} to its implementation \doxylink{_menu_options_factory_8cs}{Menu\+Options\+Factory.\+cs} \mbox{[} \mbox{]} /\+Namespaces/\+Models/\+Tree\+View\+Helper\+CSharp\+Class.cs \mbox{[} \mbox{]} /\+Namespaces/\+Models/\+Tree\+View\+Helper\+CSharp\+Project.cs \mbox{[} \mbox{]} /\+Namespaces/\+Models/\+Tree\+View\+Helper\+Razor\+Markup.cs \mbox{[} \mbox{]} /\+Shareds/\+Displays/\+Internals/\+Ide\+Prompt\+Open\+Solution\+Display.razor \mbox{[} \mbox{]} /\+Test\+Explorers/ \#\#\#\#\#\# Should /\+Test\+Explorers/ be moved???? \mbox{[} \mbox{]} /\+Namespaces/ \#\#\#\#\#\# Should /\+Namespaces/ be moved????

I need to make a \textquotesingle{}Workspace\textquotesingle{} concept in order to permit arbitrary grouping of directories into a tree view.

I moved over \textquotesingle{}/\+CSharp\+Projects/\textquotesingle{} and it is immediately apparent that this will be a headache. Some of the code in \textquotesingle{}/\+CSharp\+Projects/\textquotesingle{} relies on various bits and pieces of code that exist within the IDE, so I\textquotesingle{}ll get a circular reference if I try to take the shortcut of having the IDE reference my new project for time being 
