\doxysection{Source/\+Lib/\+Text\+Editor/\+Text\+Editors/\+Models Directory Reference}
\hypertarget{dir_d5746557a2b08703fb8a56d986f6faef}{}\label{dir_d5746557a2b08703fb8a56d986f6faef}\index{Source/Lib/TextEditor/TextEditors/Models Directory Reference@{Source/Lib/TextEditor/TextEditors/Models Directory Reference}}


/// Tab\+Index is used for the html attribute named\+: \textquotesingle{}tabindex\textquotesingle{} ///  


Directory dependency graph for Models\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=248pt]{dir_d5746557a2b08703fb8a56d986f6faef_dep}
\end{center}
\end{figure}
\doxysubsubsection*{Directories}
\begin{DoxyCompactItemize}
\item 
directory \mbox{\hyperlink{dir_2fc4d8226f1c563d55c9a0c8ec4be3d5}{Internals}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Files}
\begin{DoxyCompactItemize}
\item 
file \mbox{\hyperlink{_category_8cs}{Category.\+cs}}
\item 
file \mbox{\hyperlink{_cursor_modifier_bag_text_editor_8cs}{Cursor\+Modifier\+Bag\+Text\+Editor.\+cs}}
\item 
file \mbox{\hyperlink{_dynamic_view_model_adapter_text_editor_8cs}{Dynamic\+View\+Model\+Adapter\+Text\+Editor.\+cs}}
\item 
file \mbox{\hyperlink{_extension_no_period_facts_8cs}{Extension\+No\+Period\+Facts.\+cs}}
\item 
file \mbox{\hyperlink{_i_tab_text_editor_8cs}{ITab\+Text\+Editor.\+cs}}
\item 
file \mbox{\hyperlink{_i_text_editor_dependent_component_8cs}{IText\+Editor\+Dependent\+Component.\+cs}}
\item 
file \mbox{\hyperlink{_i_text_editor_edit_context_8cs}{IText\+Editor\+Edit\+Context.\+cs}}
\item 
file \mbox{\hyperlink{_i_text_editor_model_8cs}{IText\+Editor\+Model.\+cs}}
\item 
file \mbox{\hyperlink{_i_text_editor_model_api_8cs}{IText\+Editor\+Model\+Api.\+cs}}
\item 
file \mbox{\hyperlink{_i_text_editor_view_model_api_8cs}{IText\+Editor\+View\+Model\+Api.\+cs}}
\item 
file \mbox{\hyperlink{_keymap_args_kind_8cs}{Keymap\+Args\+Kind.\+cs}}
\item 
file \mbox{\hyperlink{_motion_kind_8cs}{Motion\+Kind.\+cs}}
\item 
file \mbox{\hyperlink{_scrollbar_dimensions_8cs}{Scrollbar\+Dimensions.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_dimensions_8cs}{Text\+Editor\+Dimensions.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_8_main_8cs}{Text\+Editor\+Model.\+Main.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_8_variables_8cs}{Text\+Editor\+Model.\+Variables.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_api_8cs}{Text\+Editor\+Model\+Api.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_extension_methods_8cs}{Text\+Editor\+Model\+Extension\+Methods.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_modifier_8_bad_8cs}{Text\+Editor\+Model\+Modifier.\+Bad.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_modifier_8_edit_methods_8cs}{Text\+Editor\+Model\+Modifier.\+Edit\+Methods.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_modifier_8_in_progress_8cs}{Text\+Editor\+Model\+Modifier.\+In\+Progress.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_modifier_8_main_8cs}{Text\+Editor\+Model\+Modifier.\+Main.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_model_modifier_8_partitions_8cs}{Text\+Editor\+Model\+Modifier.\+Partitions.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_partition_8cs}{Text\+Editor\+Partition.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_view_model_8cs}{Text\+Editor\+View\+Model.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_view_model_api_8cs}{Text\+Editor\+View\+Model\+Api.\+cs}}
\item 
file \mbox{\hyperlink{_text_editor_view_model_modifier_8cs}{Text\+Editor\+View\+Model\+Modifier.\+cs}}
\item 
file \mbox{\hyperlink{_widget_block_8cs}{Widget\+Block.\+cs}}
\item 
file \mbox{\hyperlink{_widget_inline_8cs}{Widget\+Inline.\+cs}}
\item 
file \mbox{\hyperlink{_widget_overlay_8cs}{Widget\+Overlay.\+cs}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
/// Tab\+Index is used for the html attribute named\+: \textquotesingle{}tabindex\textquotesingle{} /// 

Text editor virtualization\+:

public record Text\+Editor\+View\+Model\+Display\+Parameters(\+Key$<$\+Text\+Editor\+View\+Model$>$ View\+Model\+Key) \{ public string Wrapper\+Style\+Css\+String \{ get; init; \} = string.\+Empty; public string Wrapper\+Class\+Css\+String \{ get; init; \} = string.\+Empty; public string Text\+Editor\+Style\+Css\+String \{ get; init; \} = string.\+Empty; public string Text\+Editor\+Class\+Css\+String \{ get; init; \} = string.\+Empty;

/// public int Tab\+Index \{ get; init; \} = -\/1; public Render\+Fragment$<$\+Text\+Editor\+Render\+Batch\+Validated$>$? Context\+Menu\+Render\+Fragment\+Override \{ get; init; \} public Render\+Fragment$<$\+Text\+Editor\+Render\+Batch\+Validated$>$? Auto\+Complete\+Menu\+Render\+Fragment\+Override \{ get; init; \}

///

/// If left null, the default Handle\+After\+On\+Key\+Down\+Async will be used. /// public Func$<$\+IText\+Editor\+Edit\+Context, Text\+Editor\+Model\+Modifier, Text\+Editor\+View\+Model\+Modifier, Cursor\+Modifier\+Bag\+Text\+Editor, Keyboard\+Event\+Args, Text\+Editor\+Component\+Data, Task$>$? After\+On\+Key\+Down\+Async \{ get; init; \}

///

/// If left null, the default Handle\+After\+On\+Key\+Down\+Range\+Async will be used. /// /// If a batch handling of Keyboard\+Event\+Args is performed, then this method will be invoked as opposed to /// After\+On\+Key\+Down\+Async\+Factory, and a list of Keyboard\+Event\+Args will be provided, /// sorted such that the first index represents the first event fired, and the last index represents the last /// event fired. /// public Func\texorpdfstring{$<$}{<}IText\+Editor\+Edit\+Context, Text\+Editor\+Model\+Modifier, Text\+Editor\+View\+Model\+Modifier, Cursor\+Modifier\+Bag\+Text\+Editor, List$<$\+Keyboard\+Event\+Args$>$, Text\+Editor\+Component\+Data, Task\texorpdfstring{$>$}{>}? After\+On\+Key\+Down\+Range\+Async \{ get; init; \}

///

/// If set to false the Displays.\+Internals.\+Header will NOT render above the text editor. /// public bool Include\+Header\+Helper\+Component \{ get; init; \} = true;

///

/// Header\+Button\+Kinds contains the enum value that represents a button displayed in the optional component\+: Text\+Editor\+Header. /// public Immutable\+Array$<$\+Header\+Button\+Kind$>$? Header\+Button\+Kinds \{ get; init; \}

///

/// If set to false the Displays.\+Internals.\+Text\+Editor\+Footer will NOT render below the text editor. /// public bool Include\+Footer\+Helper\+Component \{ get; init; \} = true;

///

/// If set to false\+: the Displays.\+Internals.\+Gutter\+Section will NOT render. (i.\+e. line numbers will not render) /// public bool Include\+Gutter\+Component \{ get; init; \} = true;

public bool Include\+Context\+Menu\+Helper\+Component \{ get; init; \} = true;

public Context\+Record Context\+Record \{ get; init; \} = Context\+Facts.\+Text\+Editor\+Context;

///

/// The integrated terminal logic needs a keymap, separate to that of the \textquotesingle{}global\textquotesingle{} keymap used by other text editors. /// Therefore, this property is used to provide the Keymaps.\+Models.\+Terminals.\+Text\+Editor\+Keymap\+Terminal /// to the integrated terminal.~\newline
~\newline
 /// /// This property is not intended for use in any other scenario. /// public Keymap? Keymap\+Override \{ get; init; \} \}

public sealed partial class Text\+Editor\+View\+Model\+Display \+: Component\+Base, IDisposable \{ \mbox{[}Inject\mbox{]} public IState$<$\+Text\+Editor\+State$>$ Text\+Editor\+State\+Wrap \{ get; set; \} = null!;

\mbox{[}Parameter\mbox{]} public Text\+Editor\+View\+Model\+Display\+Parameters View\+Model\+Display\+Parameters \{ get; set; \} = new();

private (Key$<$\+Text\+Editor\+View\+Model$>$ View\+Model\+Key, int Sequence) \+\_\+view\+Model\+Sequence\+Tuple = (Key$<$\+Text\+Editor\+View\+Model$>$.\+Empty, 0);

protected override void On\+Parameters\+Set() \{ if (View\+Model\+Display\+Parameters.\+View\+Model\+Key != \+\_\+view\+Model\+Sequence\+Tuple.\+View\+Model\+Key) \{ \+\_\+view\+Model\+Sequence\+Tuple = (View\+Model\+Display\+Parameters.\+View\+Model\+Key, 0); \}

base.\+On\+Parameters\+Set(); \}

protected override bool Should\+Render() \{ // Is this invocation to the base necessary? // And, where would it go if it were necessary. var should\+Render = base.\+Should\+Render();

// Goal is to create a back and forth communication where the UI notifies // some \textquotesingle{}external\textquotesingle{} code that it wishes to render the text editor. // I\textquotesingle{}ll just call the \textquotesingle{}external\textquotesingle{} code the \textquotesingle{}IState$<$\+Text\+Editor\+State$>$ Text\+Editor\+State\+Wrap\textquotesingle{} // but that isn\textquotesingle{}t quite so accurate. // // Upon the very first render, \textquotesingle{}Should\+Render()\textquotesingle{} does not get invoked. // This should be fine, because we need to render at least once in order to draw // the text editor HTML element. // // The text editor HTML element goes on to take up 100\% width and height of the parent element. // So, the very first render allows one to draw an empty text editor, and measure its width, and height. // // These width and height measurements can then be used for virtualization at a later point. // // Inside \textquotesingle{}override Task On\+After\+Render\+Async(bool first\+Render)\textquotesingle{} there is a conditional branch // that will cause a re-\/render if it is the first render. // // So, we now are at the start of the second render, in which \textquotesingle{}Should\+Render\textquotesingle{} will for the first time be ran. // // At this point we have the measurements of the text editor HTML element because an empty one was rendered. // // But, we don\textquotesingle{}t have a virtualization result that tells us what content to display. // // So, we need to notify the Text\+Editor\+State\+Wrap that we intend to render something. // We pass to the Text\+Editor\+State\+Wrap our \textquotesingle{}\+\_\+view\+Model\+Sequence\+Tuple\textquotesingle{}. // // If the \+\_\+view\+Model\+Sequence\+Tuple.\+Sequence == (the most recent sequence in the Text\+Editor\+State\+Wrap) // then no render is needed, the UI is up to date. // // Anytime a model is modified, all of its corresponding View\+Models need to have their // Sequence incremented. // // As well, anytime a View\+Model itself is modified, increment its sequence. // // And if the text editor\textquotesingle{}s settings are changed (such as the font size) then increment // the sequence for every View\+Model. // // But, its important to note that the previous events solely incremented the Sequence. // // It is up to the user interface (i.\+e. the text editor component) to notify its attempt // to render. // // At that moment, if the View\+Model\textquotesingle{}s Observed\+Sequence is not equal to its // Running\+Sequence then the Virtualization\+Result is to be calculated, // and \textquotesingle{}false\textquotesingle{} should be returned, because it would have rendered outdated // information. // // After the Virtualization\+Result is calculated, trigger the UI to render. // This once again will enter this \textquotesingle{}Should\+Render\textquotesingle{} method. // // But, this time when notifying the \textquotesingle{}Text\+Editor\+State\+Wrap\textquotesingle{} that it intends to render, // the response is \textquotesingle{}true\textquotesingle{} because the Observed\+Sequence was updated to be equal to the // Running\+Sequence after the Virtualization\+Result was calculated. // // So, true is returned and the content is rendered.

// As for the virtualization, there is no need for the Java\+Script intersection observer. // The IText\+Editor\+Edit\+Context knows everything about the scroll position, and other data relating to the text editor. // So the virtualization can just be done then and there.

View\+Model\+Display\+Parameters.\+View\+Model\+Key; \}

// Random note before I forget\+: options changes should be done via a throttled effect that // triggers UI re-\/render 100x easier than what I\textquotesingle{}m currently doing.

protected override async Task On\+After\+Render\+Async(bool first\+Render) \{ if (first\+Render) \{ // If we were to use the synchronous \textquotesingle{}On\+After\+Render\textquotesingle{} version of this method. // Could we guarantee that an invocation to \textquotesingle{}State\+Has\+Changed\textquotesingle{} would not // need to be put within an invocation to \textquotesingle{}Invoke\+Async\textquotesingle{}? // // The worry being, an exception due to not being on the correct synchronization context. // If this override serves only to cause a re-\/render after the very first render, // then it may be a worthwhile optimization to swap this method to the synchronous version // if it would be safe to do so. await Invoke\+Async(\+State\+Has\+Changed); \}

// Is this invocation to the base necessary? // And, where would it go if it were necessary. await base.\+On\+After\+Render\+Async(); \} \} 
